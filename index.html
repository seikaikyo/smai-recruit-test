<!DOCTYPE html>
<html lang="zh-TW" data-theme="cupcake">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SMAI 技術人才測驗系統</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdn.jsdelivr.net/npm/daisyui@4.12.22/dist/full.min.css" rel="stylesheet">
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        [v-cloak] { display: none; }

        /* 主題系統 - 日系莫蘭迪風格 */
        :root, html, html[data-theme="caramel"] {
            /* 焦糖奶茶 (預設) */
            --primary-light: #C4A77D;
            --primary-dark: #8B7355;
            --primary-text: #5D4E37;
            --bg-cream: #FDF8F3;
            --bg-light: #F5EDE4;
            --bg-medium: #E8DED3;
            --accent-pink: #E8C4C4;
            --accent-green: #B4C4AE;
            --accent-blue: #A8C5D9;
            --accent-yellow: #F5E6C8;
        }

        html[data-theme="matcha"], html[data-theme="matcha"] body {
            --primary-light: #9DB4A0;
            --primary-dark: #6B8E6B;
            --primary-text: #3D5A3D;
            --bg-cream: #F0F5F0;
            --bg-light: #E0EBE0;
            --bg-medium: #C8D8C8;
            --accent-pink: #E8D4D4;
            --accent-green: #A8C4A8;
            --accent-blue: #B4D4E0;
            --accent-yellow: #E8F0D8;
        }

        html[data-theme="sakura"], html[data-theme="sakura"] body {
            --primary-light: #DDA0A0;
            --primary-dark: #C07070;
            --primary-text: #6B4444;
            --bg-cream: #FFF5F5;
            --bg-light: #FFE8E8;
            --bg-medium: #F8D0D0;
            --accent-pink: #F0C4C4;
            --accent-green: #C4D8C4;
            --accent-blue: #D4D4E8;
            --accent-yellow: #F8E8D8;
        }

        html[data-theme="fuji"], html[data-theme="fuji"] body {
            --primary-light: #A898B8;
            --primary-dark: #806090;
            --primary-text: #4A4058;
            --bg-cream: #F8F5FC;
            --bg-light: #EDE8F4;
            --bg-medium: #D8D0E0;
            --accent-pink: #E0C8D8;
            --accent-green: #C8D8C8;
            --accent-blue: #C8D0E8;
            --accent-yellow: #E8E0F0;
        }

        html[data-theme="orange"], html[data-theme="orange"] body {
            --primary-light: #E8A060;
            --primary-dark: #C87830;
            --primary-text: #5A3820;
            --bg-cream: #FFF8F0;
            --bg-light: #FFE8D8;
            --bg-medium: #F0D0B8;
            --accent-pink: #F8D0C0;
            --accent-green: #D8E0C8;
            --accent-blue: #D0E0F0;
            --accent-yellow: #FFE8C0;
        }

        /* 深色模式 - 各主題的夜間版本 */
        html.dark[data-theme="caramel"], html.dark:not([data-theme]) {
            --primary-light: #9B8A6A;
            --primary-dark: #6B5A45;
            --primary-text: #E8DED0;
            --bg-cream: #1A1815;
            --bg-light: #252218;
            --bg-medium: #3A3428;
            --accent-pink: #C4A0A0;
            --accent-green: #8CA088;
            --accent-blue: #88A0B0;
            --accent-yellow: #C0A888;
        }
        html.dark[data-theme="matcha"] {
            --primary-light: #7A9A7A;
            --primary-dark: #506850;
            --primary-text: #D8E8D8;
            --bg-cream: #141A14;
            --bg-light: #1E281E;
            --bg-medium: #2A3A2A;
            --accent-pink: #C0A8A8;
            --accent-green: #88A888;
            --accent-blue: #90B0B8;
            --accent-yellow: #B8C8A0;
        }
        html.dark[data-theme="sakura"] {
            --primary-light: #B07878;
            --primary-dark: #905050;
            --primary-text: #F0E0E0;
            --bg-cream: #1A1414;
            --bg-light: #281E1E;
            --bg-medium: #3A2828;
            --accent-pink: #C09090;
            --accent-green: #98B098;
            --accent-blue: #A0A0C0;
            --accent-yellow: #C8B8A8;
        }
        html.dark[data-theme="fuji"] {
            --primary-light: #887898;
            --primary-dark: #604870;
            --primary-text: #E8E0F0;
            --bg-cream: #161418;
            --bg-light: #201E28;
            --bg-medium: #302838;
            --accent-pink: #B8A0B0;
            --accent-green: #A0B0A0;
            --accent-blue: #A0A8C0;
            --accent-yellow: #C0B8D0;
        }
        html.dark[data-theme="orange"] {
            --primary-light: #B88048;
            --primary-dark: #986028;
            --primary-text: #F0E8E0;
            --bg-cream: #1A1610;
            --bg-light: #282018;
            --bg-medium: #3A3020;
            --accent-pink: #C8A898;
            --accent-green: #A8B898;
            --accent-blue: #A8B8C8;
            --accent-yellow: #C8B898;
        }
        html.dark .card {
            background: var(--bg-cream) !important;
            color: var(--primary-text) !important;
        }
        html.dark .input,
        html.dark .textarea {
            background: var(--bg-light) !important;
            color: var(--primary-text) !important;
            border-color: var(--bg-medium) !important;
        }
        html.dark .badge {
            color: var(--primary-text) !important;
        }
        html.dark body {
            background: linear-gradient(135deg, var(--bg-cream) 0%, var(--bg-light) 100%) !important;
        }

        /* 全域過渡動畫 */
        * {
            transition: background-color 0.4s ease, border-color 0.4s ease, color 0.3s ease, box-shadow 0.3s ease;
        }

        body {
            background: linear-gradient(135deg, #FDF8F3 0%, #F5EDE4 100%);
            color: var(--primary-text);
            min-height: 100vh;
        }
        html[data-theme="matcha"] body {
            background: linear-gradient(135deg, #F0F5F0 0%, #E0EBE0 100%) !important;
        }
        html[data-theme="sakura"] body {
            background: linear-gradient(135deg, #FFF5F5 0%, #FFE8E8 100%) !important;
        }
        html[data-theme="fuji"] body {
            background: linear-gradient(135deg, #F8F5FC 0%, #EDE8F4 100%) !important;
        }

        /* Header 漸層 */
        .navbar {
            background: linear-gradient(90deg, var(--primary-light) 0%, var(--primary-dark) 100%) !important;
            color: white !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        /* 主題切換器 */
        .theme-switcher {
            display: flex;
            gap: 8px;
            padding: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 20px;
        }
        .theme-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        .theme-btn:hover {
            transform: scale(1.15);
            border-color: white;
        }
        .theme-btn.active {
            border-color: white;
            box-shadow: 0 0 0 3px rgba(255,255,255,0.3);
        }
        .theme-btn.active::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
        }
        .theme-caramel { background: linear-gradient(135deg, #C4A77D, #8B7355); }
        .theme-matcha { background: linear-gradient(135deg, #9DB4A0, #6B8E6B); }
        .theme-sakura { background: linear-gradient(135deg, #E8B4B4, #C48888); }
        .theme-fuji { background: linear-gradient(135deg, #B4A8C4, #887898); }
        .theme-orange { background: linear-gradient(135deg, #E8A060, #C87830); }
        .theme-dark { background: linear-gradient(135deg, #3D5A80, #1A1A2E); }

        /* 打字機動畫 */
        .typewriter {
            overflow: hidden;
            border-right: 3px solid var(--primary-light);
            white-space: nowrap;
            animation: typing 2s steps(20, end), blink-caret 0.75s step-end infinite;
        }
        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }
        @keyframes blink-caret {
            from, to { border-color: transparent }
            50% { border-color: var(--primary-light) }
        }

        /* 倒數計時器 */
        .timer-ring {
            transform: rotate(-90deg);
        }
        .timer-ring circle {
            fill: none;
            stroke-width: 4;
            stroke-linecap: round;
        }
        .timer-bg { stroke: var(--bg-medium); }
        .timer-progress {
            stroke: var(--primary-light);
            transition: stroke-dashoffset 1s linear;
        }
        .timer-danger { stroke: #E94560 !important; }

        /* 粒子背景 */
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }
        .particle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--primary-light);
            border-radius: 50%;
            opacity: 0.3;
            animation: float 15s infinite ease-in-out;
        }
        @keyframes float {
            0%, 100% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
            10% { opacity: 0.3; }
            90% { opacity: 0.3; }
            100% { transform: translateY(-100vh) rotate(720deg); opacity: 0; }
        }

        /* Confetti */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            overflow: hidden;
        }
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0;
            animation: confetti-fall 3s ease-out forwards;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(-100px) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        /* 快捷鍵提示 */
        .shortcut-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 12px 16px;
            border-radius: 12px;
            font-size: 12px;
            z-index: 100;
            opacity: 0.8;
        }
        .shortcut-hint kbd {
            background: rgba(255,255,255,0.2);
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
        }

        /* 卡片樣式 */
        .card {
            background: white !important;
            border: 1px solid var(--bg-medium) !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08) !important;
            border-radius: 16px !important;
        }

        /* 按鈕樣式 */
        .btn-primary {
            background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-dark) 100%) !important;
            border: none !important;
            color: white !important;
            border-radius: 12px !important;
            font-weight: 600 !important;
        }
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15) !important;
        }
        .btn-primary:disabled {
            background: var(--bg-medium) !important;
            opacity: 0.6;
            transform: none;
        }
        .btn-ghost {
            color: var(--primary-text) !important;
        }
        .btn-success {
            background: linear-gradient(135deg, var(--accent-green), #8BA888) !important;
            color: white !important;
        }

        /* Alert 樣式 */
        .alert-info {
            background: linear-gradient(135deg, var(--accent-blue), #B8D4E8) !important;
            border: none !important;
            color: var(--primary-text) !important;
            border-radius: 12px !important;
        }
        .alert-warning {
            background: linear-gradient(135deg, var(--accent-yellow), var(--bg-medium)) !important;
            border: none !important;
            color: var(--primary-text) !important;
            border-radius: 12px !important;
        }

        /* 進度條 */
        .progress {
            height: 10px !important;
            background: var(--bg-medium) !important;
            border-radius: 5px !important;
            overflow: hidden !important;
        }
        .progress::-webkit-progress-bar {
            background: var(--bg-medium);
            border-radius: 5px;
        }
        .progress::-webkit-progress-value {
            background: linear-gradient(90deg, var(--primary-light), var(--primary-dark));
            border-radius: 5px;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .progress::-moz-progress-bar {
            background: linear-gradient(90deg, var(--primary-light), var(--primary-dark));
            border-radius: 5px;
        }

        /* Radio 選中狀態 */
        .radio {
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid var(--bg-medium);
            border-radius: 50%;
            cursor: pointer;
            background: white;
        }
        .radio:checked {
            border-color: var(--primary-light);
            background: radial-gradient(circle, var(--primary-light) 40%, white 45%);
        }
        .radio:hover {
            border-color: var(--primary-light);
        }

        /* 職位選項卡片 */
        .card.bg-base-200 {
            background: var(--bg-light) !important;
            border: 2px solid transparent !important;
            border-radius: 12px !important;
        }
        .card.bg-base-200:hover {
            background: var(--bg-medium) !important;
            border-color: var(--primary-light) !important;
            transform: translateY(-2px);
        }
        .card.ring-2 {
            border-color: var(--primary-light) !important;
            background: white !important;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1) !important;
        }

        /* Badge 標籤 */
        .badge {
            border: 1px solid var(--bg-medium) !important;
            background: var(--bg-light) !important;
            color: var(--primary-text) !important;
            border-radius: 8px !important;
        }
        .badge-info { background: var(--accent-blue) !important; }
        .badge-warning { background: var(--accent-yellow) !important; }
        .badge-error { background: var(--accent-pink) !important; }
        .badge-success { background: var(--accent-green) !important; }
        .badge-neutral { background: var(--bg-medium) !important; }
        .badge-secondary { background: linear-gradient(135deg, #E8A060, #C87830) !important; color: white !important; }
        .badge-ghost {
            background: transparent !important;
            border: 1px dashed var(--bg-medium) !important;
        }

        /* 輸入框 */
        .input, .textarea {
            border: 2px solid var(--bg-medium) !important;
            background: white !important;
            border-radius: 10px !important;
        }
        .input:focus, .textarea:focus {
            border-color: var(--primary-light) !important;
            box-shadow: 0 0 0 3px rgba(0,0,0,0.05) !important;
            outline: none !important;
        }

        /* 選項列表 */
        .option-card {
            background: var(--bg-light);
            border-radius: 10px;
            padding: 12px 16px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .option-card:hover {
            background: var(--bg-medium);
            border-color: var(--primary-light);
        }
        .option-card.selected {
            background: white;
            border-color: var(--primary-light);
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        }

        /* 測驗選項 */
        .option-item {
            background: var(--bg-light) !important;
            border: 1px solid var(--bg-medium);
        }
        .option-item:hover {
            background: var(--bg-medium) !important;
            border-color: var(--primary-light);
        }
        .option-item.ring-2 {
            background: white !important;
            border-color: var(--primary-light) !important;
        }

        /* AI 助理提示區 */
        .ai-assistant-bar {
            background: linear-gradient(90deg, var(--bg-light) 0%, var(--bg-cream) 100%);
            border-bottom: 1px solid var(--bg-medium);
            position: sticky;
            top: 0;
            z-index: 50;
        }
        .ai-avatar {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary-light), var(--primary-dark));
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(200, 120, 48, 0.4); }
            50% { box-shadow: 0 0 0 8px rgba(200, 120, 48, 0); }
        }
        .ai-message {
            font-size: 0.875rem;
            color: var(--primary-text);
        }
        .typing-text {
            display: inline-block;
        }
        html[data-theme="dark"] .ai-assistant-bar {
            background: linear-gradient(90deg, #16213E 0%, #1A1A2E 100%);
        }

        /* Footer */
        .footer {
            background: var(--bg-medium) !important;
            color: var(--primary-text) !important;
        }

        /* Code Block */
        .code-block {
            background: #2D2A26;
            color: #E8DED3;
            padding: 1rem;
            border-radius: 12px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.875rem;
            overflow-x: auto;
            white-space: pre;
            border: 1px solid var(--primary-dark);
        }
        .keyword { color: var(--primary-light); }
        .string { color: var(--accent-pink); }
        .comment { color: var(--accent-green); }
        .function { color: var(--accent-blue); }

        /* Stats */
        .stats {
            background: white !important;
            border: 1px solid var(--bg-medium) !important;
            border-radius: 12px !important;
        }
        .stat-value { color: var(--primary-dark) !important; }

        /* Collapse */
        .collapse {
            background: var(--bg-light) !important;
            border: 1px solid var(--bg-medium) !important;
            border-radius: 12px !important;
        }

        /* 動畫效果 */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .card-body { animation: fadeIn 0.4s ease; }

        /* 主題名稱 tooltip */
        .theme-btn[title]:hover::before {
            content: attr(title);
            position: absolute;
            bottom: -28px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
        }
    </style>
</head>
<body>
<div id="app" v-cloak class="min-h-screen">
    <!-- Header -->
    <div class="navbar bg-primary text-primary-content shadow-lg">
        <div class="flex-1">
            <span class="text-xl font-bold px-4">SMAI 技術人才測驗系統</span>
        </div>
        <div class="flex-none px-4 flex items-center gap-4">
            <!-- 主題切換器 -->
            <div class="theme-switcher">
                <button
                    v-for="t in themes.filter(x => x.id !== 'dark')"
                    :key="t.id"
                    :title="t.name"
                    :class="['theme-btn', 'theme-' + t.id, { active: currentTheme === t.id }]"
                    @click="setTheme(t.id)">
                </button>
            </div>
            <!-- 日夜切換 -->
            <button class="btn btn-ghost btn-circle" @click="toggleDarkMode" :title="currentTheme === 'dark' ? '切換日間模式' : '切換夜間模式'">
                <svg v-if="currentTheme !== 'dark'" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
                <svg v-else xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </button>
            <span v-if="currentStep !== 'welcome'" class="badge badge-ghost">{{ selectedPosition?.name }}</span>
        </div>
    </div>

    <!-- AI 助理提示區 -->
    <div v-if="currentStep === 'test'" class="ai-assistant-bar">
        <div class="container mx-auto px-4 py-2 flex items-center justify-between gap-3">
            <div class="flex items-center gap-3">
                <div class="ai-avatar">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/>
                    </svg>
                </div>
                <div class="ai-message">
                    <span class="typing-text">{{ aiMessage }}</span>
                </div>
            </div>
            <div v-if="behaviorStats.questionCount > 0" class="hidden sm:flex items-center gap-3 text-xs opacity-70">
                <span>平均 {{ behaviorStats.avgResponseTime }}s</span>
                <span>正確率 {{ behaviorStats.correctRate }}%</span>
            </div>
        </div>
    </div>

    <div class="container mx-auto p-4 max-w-4xl">
        <!-- Welcome Screen -->
        <div v-if="currentStep === 'welcome'" class="card bg-base-100 shadow-xl">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">歡迎參加 SMAI 技術人才測驗</h2>

                <div class="alert alert-info mb-6">
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <div>
                        <h3 class="font-bold">關於本測驗</h3>
                        <ul class="text-sm mt-2 list-disc list-inside">
                            <li><strong>鼓勵使用任何 AI 工具</strong>（Claude、ChatGPT、Copilot、Gemini 等皆可）</li>
                            <li>我們評估的是 <strong>AI 協作能力</strong>，不限定特定工具</li>
                            <li>重點在於<strong>理解問題</strong>、<strong>驗證結果</strong>和<strong>解釋思路</strong></li>
                            <li>實作題需說明<strong>為什麼這樣做</strong>，而不只是貼答案</li>
                            <li>測驗時間約 30-45 分鐘</li>
                        </ul>
                    </div>
                </div>

                <div class="alert alert-warning mb-6">
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                    </svg>
                    <div>
                        <h3 class="font-bold">測驗結構</h3>
                        <ul class="text-sm mt-2 list-disc list-inside">
                            <li><strong>Part 1：基礎必備</strong> - Git + CI/CD + AI 協作（所有職位必考）</li>
                            <li><strong>Part 2：職位專業</strong> - 依據您選擇的職位出題</li>
                            <li><strong>Part 3：情境題</strong> - 了解你的工作風格與價值觀</li>
                            <li><strong>Bonus：進階挑戰</strong> - AI 根據你的表現動態出題</li>
                        </ul>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                    <div class="form-control">
                        <label class="label"><span class="label-text font-medium">姓名 *</span></label>
                        <input type="text" v-model="userName" :placeholder="randomStar" class="input input-bordered">
                    </div>
                    <div class="form-control">
                        <label class="label"><span class="label-text font-medium">Email *</span></label>
                        <input type="email" v-model="userEmail" placeholder="email@example.com" class="input input-bordered" required>
                    </div>
                    <div class="form-control">
                        <label class="label"><span class="label-text font-medium">電話</span></label>
                        <input type="tel" v-model="userPhone" placeholder="0912-345-678" class="input input-bordered">
                    </div>
                </div>

                <div class="form-control mb-6">
                    <label class="label"><span class="label-text font-medium">請選擇應徵職位</span></label>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-3">
                        <label v-for="pos in positions" :key="pos.id"
                            class="card bg-base-200 cursor-pointer hover:bg-base-300 transition-colors"
                            :class="{ 'ring-2 ring-primary': selectedPosition?.id === pos.id }">
                            <div class="card-body p-4">
                                <div class="flex items-start gap-3">
                                    <input type="radio" name="position" :value="pos" v-model="selectedPosition" class="radio radio-primary mt-1">
                                    <div class="flex-1">
                                        <div class="flex items-center gap-2">
                                            <h3 class="font-bold">{{ pos.name }}</h3>
                                            <button type="button" class="btn btn-ghost btn-xs" @click.prevent="showJd = showJd === pos.id ? null : pos.id" title="查看職位說明">
                                                <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                                    <circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/>
                                                </svg>
                                            </button>
                                        </div>
                                        <p class="text-sm opacity-70">{{ pos.tech }}</p>
                                        <div class="flex flex-wrap gap-1 mt-2">
                                            <span v-for="project in pos.projects.slice(0, 3)" class="badge badge-sm badge-outline">{{ project }}</span>
                                            <span v-if="pos.projects.length > 3" class="badge badge-sm badge-ghost">+{{ pos.projects.length - 3 }}</span>
                                        </div>
                                        <!-- JD 展開區 -->
                                        <div v-if="showJd === pos.id" class="mt-3 p-3 rounded-lg text-xs whitespace-pre-line" style="background: var(--bg-light);">
                                            {{ pos.jd }}
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </label>
                    </div>
                </div>

                <div class="card-actions justify-end">
                    <button class="btn btn-primary" :disabled="!userName || !userEmail || !selectedPosition" @click="startTest">
                        開始測驗
                    </button>
                </div>
            </div>
        </div>

        <!-- Test Screen -->
        <div v-if="currentStep === 'test'" class="space-y-4">
            <!-- Progress + Timer -->
            <div class="flex items-center gap-4 mb-6">
                <progress class="progress progress-primary flex-1" :value="currentQuestionIndex + 1" :max="currentQuestions.length"></progress>
                <span class="text-sm font-medium">{{ currentQuestionIndex + 1 }} / {{ currentQuestions.length }}</span>
                <!-- 倒數計時器 -->
                <div class="flex items-center gap-2">
                    <svg class="timer-ring" width="36" height="36">
                        <circle class="timer-bg" cx="18" cy="18" r="14"></circle>
                        <circle class="timer-progress" :class="{ 'timer-danger': timerDanger }"
                            cx="18" cy="18" r="14"
                            :stroke-dasharray="88"
                            :stroke-dashoffset="88 - (88 * timerProgress / 100)">
                        </circle>
                    </svg>
                    <span class="text-sm font-mono" :class="{ 'text-red-500 font-bold': timerDanger }">
                        {{ timeRemaining }}s
                    </span>
                </div>
            </div>

            <!-- Question Card -->
            <div class="card bg-base-100 shadow-xl">
                <div class="card-body">
                    <div class="flex items-center gap-2 mb-2 flex-wrap">
                        <span v-if="currentQuestion.category" class="badge" :class="currentQuestion.category === '人格特質' ? 'badge-secondary' : 'badge-neutral'">{{ currentQuestion.category }}</span>
                        <span class="badge" :class="getTypeBadgeClass(currentQuestion.type, currentQuestion.category)">{{ currentQuestion.category === '人格特質' ? '情境題' : getTypeLabel(currentQuestion.type) }}</span>
                        <span class="badge badge-outline">{{ currentQuestion.difficulty }}</span>
                    </div>

                    <h2 class="card-title text-lg">{{ currentQuestion.question }}</h2>

                    <!-- Code Block if any -->
                    <div v-if="currentQuestion.code" class="code-block mt-4" v-html="formatCode(currentQuestion.code)"></div>

                    <!-- Multiple Choice -->
                    <div v-if="currentQuestion.type === 'choice'" class="mt-6 space-y-3">
                        <label v-for="(option, idx) in currentQuestion.options" :key="idx"
                            class="flex items-center gap-3 p-3 rounded-lg option-item cursor-pointer transition-colors"
                            :class="{ 'ring-2 ring-primary bg-primary/10': answers[currentQuestionIndex] === idx }">
                            <input type="radio" :value="idx" v-model="answers[currentQuestionIndex]" @change="trackAnswerChange" class="radio radio-primary">
                            <span>{{ option }}</span>
                        </label>
                    </div>

                    <!-- Text Answer (Implementation / Code Review) -->
                    <div v-if="currentQuestion.type === 'implement' || currentQuestion.type === 'review'" class="mt-6">
                        <div class="alert alert-warning mb-4">
                            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
                            </svg>
                            <span>可以使用 AI 輔助，但請<strong>說明你的思路</strong>和<strong>為什麼這樣做</strong></span>
                        </div>
                        <textarea v-model="answers[currentQuestionIndex]"
                            class="textarea textarea-bordered w-full h-48"
                            :placeholder="currentQuestion.type === 'implement' ? '請寫出你的解決方案和思路說明...' : '請指出問題並說明原因...'"></textarea>
                    </div>

                    <!-- Navigation -->
                    <div class="card-actions flex-col sm:flex-row justify-between gap-2 mt-6">
                        <button class="btn btn-ghost w-full sm:w-auto order-2 sm:order-1" :disabled="currentQuestionIndex === 0" @click="prevQuestion">
                            上一題
                        </button>
                        <button v-if="currentQuestionIndex < currentQuestions.length - 1" class="btn btn-primary w-full sm:w-auto order-1 sm:order-2" @click="nextQuestion">
                            下一題
                        </button>
                        <button v-else class="btn btn-success w-full sm:w-auto order-1 sm:order-2" @click="submitTest">
                            提交測驗
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Loading Challenge Screen -->
        <div v-if="isGeneratingChallenge" class="card bg-base-100 shadow-xl">
            <div class="card-body text-center py-16">
                <div class="ai-avatar mx-auto mb-4" style="width: 64px; height: 64px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 8V4H8"/><rect width="16" height="12" x="4" y="8" rx="2"/><path d="M2 14h2"/><path d="M20 14h2"/><path d="M15 13v2"/><path d="M9 13v2"/>
                    </svg>
                </div>
                <h2 class="text-xl font-bold mb-2">AI 正在為你準備進階挑戰題...</h2>
                <p class="opacity-70">根據你的作答表現，生成個人化題目中</p>
                <span class="loading loading-dots loading-lg mt-4" style="color: var(--primary-light);"></span>
            </div>
        </div>

        <!-- Challenge Screen -->
        <div v-if="currentStep === 'challenge'" class="space-y-4">
            <!-- Progress -->
            <div class="flex items-center gap-4 mb-6">
                <div class="badge badge-secondary px-4 py-3">進階挑戰</div>
                <progress class="progress progress-secondary flex-1" :value="currentChallengeIndex + 1" :max="challengeQuestions.length"></progress>
                <span class="text-sm font-medium">{{ currentChallengeIndex + 1 }} / {{ challengeQuestions.length }}</span>
                <!-- Timer -->
                <div class="flex items-center gap-2">
                    <svg class="timer-ring" width="36" height="36">
                        <circle class="timer-bg" cx="18" cy="18" r="14"></circle>
                        <circle class="timer-progress" :class="{ 'timer-danger': timerDanger }"
                            cx="18" cy="18" r="14"
                            :stroke-dasharray="88"
                            :stroke-dashoffset="88 - (88 * timerProgress / 100)">
                        </circle>
                    </svg>
                    <span class="text-sm font-mono" :class="{ 'text-red-500 font-bold': timerDanger }">
                        {{ timeRemaining }}s
                    </span>
                </div>
            </div>

            <!-- Challenge Info -->
            <div class="alert mb-4" style="background: linear-gradient(135deg, var(--primary-light), var(--primary-dark)); color: white;">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                </svg>
                <span>這是 AI 根據你的表現生成的個人化題目，答案將由面試官評估</span>
            </div>

            <!-- Question Card -->
            <div class="card bg-base-100 shadow-xl">
                <div class="card-body">
                    <div class="flex items-center gap-2 mb-2 flex-wrap">
                        <span class="badge badge-secondary">AI 生成</span>
                        <span class="badge badge-neutral">{{ currentChallenge.category }}</span>
                        <span class="badge badge-outline">{{ currentChallenge.difficulty }}</span>
                    </div>

                    <h2 class="card-title text-lg">{{ currentChallenge.question }}</h2>

                    <!-- Multiple Choice -->
                    <div v-if="currentChallenge.options" class="mt-6 space-y-3">
                        <label v-for="(option, idx) in currentChallenge.options" :key="idx"
                            class="flex items-center gap-3 p-3 rounded-lg option-item cursor-pointer transition-colors"
                            :class="{ 'ring-2 ring-primary bg-primary/10': challengeAnswers[currentChallengeIndex] === idx }">
                            <input type="radio" :value="idx" v-model="challengeAnswers[currentChallengeIndex]" class="radio radio-primary">
                            <span>{{ option }}</span>
                        </label>
                    </div>

                    <!-- Text Answer -->
                    <div v-else class="mt-6">
                        <textarea v-model="challengeAnswers[currentChallengeIndex]"
                            class="textarea textarea-bordered w-full h-48"
                            placeholder="請寫出你的答案和思路說明..."
                            maxlength="5000"></textarea>
                        <div class="text-right text-xs opacity-50 mt-1">
                            {{ (challengeAnswers[currentChallengeIndex] || '').length }} / 5000
                        </div>
                    </div>

                    <!-- Navigation -->
                    <div class="card-actions flex-col sm:flex-row justify-between gap-2 mt-6">
                        <div></div>
                        <button v-if="currentChallengeIndex < challengeQuestions.length - 1" class="btn btn-primary w-full sm:w-auto" @click="nextChallenge">
                            下一題
                        </button>
                        <button v-else class="btn btn-success w-full sm:w-auto" @click="submitChallenge">
                            完成挑戰
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Result Screen -->
        <div v-if="currentStep === 'result'" class="card bg-base-100 shadow-xl">
            <div class="card-body">
                <h2 class="card-title text-2xl mb-4">測驗完成！</h2>

                <!-- 根據分數顯示鼓勵訊息 -->
                <div class="alert mb-4" :class="resultEncouragement.alertClass">
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" :d="resultEncouragement.icon" />
                    </svg>
                    <span>{{ resultEncouragement.message }}</span>
                </div>

                <div class="stats shadow mb-4 flex-wrap">
                    <div class="stat">
                        <div class="stat-title">應徵者</div>
                        <div class="stat-value text-lg">{{ userName }}</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">應徵職位</div>
                        <div class="stat-value text-lg">{{ selectedPosition?.name }}</div>
                    </div>
                    <div class="stat">
                        <div class="stat-title">技術題得分</div>
                        <div class="stat-value text-primary">{{ choiceScore }} / {{ totalChoiceQuestions }}</div>
                    </div>
                </div>

                <!-- 人格特質分析（僅供主考官檢視，不顯示給應試者） -->

                <div class="alert alert-info mb-6">
                    <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    <span>實作題和 Code Review 題需要人工審閱，我們會盡快回覆你！</span>
                </div>

                <!-- 進階挑戰題（AI 生成） -->
                <div v-if="challengeQuestions.length > 0" class="mb-6">
                    <h3 class="font-bold text-lg mb-3 flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>
                        </svg>
                        進階挑戰題（AI 個人化生成）
                    </h3>
                    <div class="alert mb-4" style="background: linear-gradient(135deg, var(--primary-light), var(--primary-dark)); color: white;">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/>
                        </svg>
                        <span>這些題目由 AI 根據你的作答表現動態生成，答案將由面試官在面談時深入評估</span>
                    </div>
                    <div class="space-y-3">
                        <div v-for="(q, idx) in challengeQuestions" :key="'c-'+idx" class="p-4 rounded-xl" style="background: var(--bg-light); border: 2px solid var(--primary-light);">
                            <div class="flex items-center gap-2 mb-2">
                                <span class="badge badge-secondary">AI 生成</span>
                                <span class="badge badge-outline">{{ q.difficulty }}</span>
                            </div>
                            <p class="font-medium mb-2">{{ q.question }}</p>
                            <p class="text-sm opacity-80">
                                <strong>你的答案：</strong>
                                <span v-if="q.options">{{ q.options[challengeAnswers[idx]] || '未作答' }}</span>
                                <span v-else class="whitespace-pre-wrap">{{ challengeAnswers[idx] || '未作答' }}</span>
                            </p>
                            <p class="text-xs mt-2 opacity-60 italic">* 此題答案將由面試官評估，不顯示參考答案</p>
                        </div>
                    </div>
                </div>

                <h3 class="font-bold text-lg mb-4">基礎測驗紀錄</h3>
                <div class="space-y-4 max-h-96 overflow-y-auto">
                    <div v-for="(q, idx) in currentQuestions" :key="idx" class="collapse collapse-arrow bg-base-200">
                        <input type="checkbox">
                        <div class="collapse-title font-medium flex flex-wrap items-center gap-2">
                            <span class="badge shrink-0" :class="getTypeBadgeClass(q.type, q.category)">{{ q.category === '人格特質' ? '情境題' : getTypeLabel(q.type) }}</span>
                            <span class="flex-1 min-w-0 truncate">{{ q.question.substring(0, 40) }}{{ q.question.length > 40 ? '...' : '' }}</span>
                            <span v-if="q.type === 'choice'" class="badge shrink-0" :class="isCorrect(idx) ? 'badge-success' : 'badge-error'">
                                {{ isCorrect(idx) ? '正確' : '錯誤' }}
                            </span>
                        </div>
                        <div class="collapse-content">
                            <p class="font-medium mb-2">題目：{{ q.question }}</p>
                            <div v-if="q.code" class="code-block mb-2 text-xs" v-html="formatCode(q.code)"></div>
                            <p class="text-sm">
                                <strong>你的答案：</strong>
                                <span v-if="q.type === 'choice'">{{ q.options[answers[idx]] || '未作答' }}</span>
                                <span v-else class="whitespace-pre-wrap">{{ answers[idx] || '未作答' }}</span>
                            </p>
                            <p v-if="q.type === 'choice'" class="text-sm text-success mt-1">
                                <strong>正確答案：</strong>{{ q.options[q.answer] }}
                            </p>
                            <div v-if="q.referenceAnswer" class="mt-3 p-3 rounded-lg" style="background: var(--accent-green); opacity: 0.9;">
                                <p class="font-medium text-sm mb-1" style="color: var(--primary-text);">參考答案：</p>
                                <pre class="text-xs whitespace-pre-wrap" style="color: var(--primary-text);">{{ q.referenceAnswer }}</pre>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="card-actions justify-end mt-6">
                    <button class="btn btn-primary" @click="resetTest">重新測驗</button>
                </div>
            </div>
        </div>
    </div>

    <!-- 快捷鍵提示 -->
    <div v-if="currentStep === 'test'" class="shortcut-hint">
        <div><kbd>1</kbd>-<kbd>4</kbd> 選答案</div>
        <div><kbd>←</kbd><kbd>→</kbd> 換題</div>
        <div><kbd>Enter</kbd> 下一題</div>
    </div>

    <!-- Footer -->
    <footer class="footer footer-center p-4 bg-base-300 text-base-content mt-8">
        <div>
            <p>SMAI 技術人才測驗系統 - 歡迎使用 AI 輔助作答</p>
            <p class="text-sm opacity-70">系統設計者 - 選我正解</p>
        </div>
    </footer>
</div>

<script>
// 立即設定主題背景（不等 Vue）
(function() {
    const bgMap = {
        caramel: 'linear-gradient(135deg, #FDF8F3 0%, #F5EDE4 100%)',
        matcha: 'linear-gradient(135deg, #F0F5F0 0%, #E0EBE0 100%)',
        sakura: 'linear-gradient(135deg, #FFF5F5 0%, #FFE8E8 100%)',
        fuji: 'linear-gradient(135deg, #F8F5FC 0%, #EDE8F4 100%)',
        orange: 'linear-gradient(135deg, #FFF8F0 0%, #FFE8D8 100%)',
        dark: 'linear-gradient(135deg, #1A1A2E 0%, #16213E 100%)'
    };
    const theme = localStorage.getItem('smai-theme') || 'orange';
    document.body.style.background = bgMap[theme];
    document.body.style.minHeight = '100vh';
    if (theme !== 'orange') {
        document.documentElement.setAttribute('data-theme', theme);
    } else {
        document.documentElement.setAttribute('data-theme', 'orange');
    }
})();

const { createApp, ref, computed, onMounted } = Vue;

createApp({
    setup() {
        // State
        const currentStep = ref('welcome'); // welcome -> test -> challenge -> result
        const userName = ref('');
        const userEmail = ref('');
        const userPhone = ref('');

        // 進階挑戰題（Claude 動態生成）
        const challengeQuestions = ref([]);
        const challengeAnswers = ref({});
        const currentChallengeIndex = ref(0);
        const isGeneratingChallenge = ref(false);
        const challengeError = ref('');
        const selectedPosition = ref(null);
        const showJd = ref(null); // 目前展開的 JD
        const currentQuestionIndex = ref(0);
        const answers = ref({});
        const isSubmitting = ref(false);
        const submitError = ref('');
        const shuffledQuestions = ref([]); // 洗牌後的題目

        // 主題系統
        // 主題配置（含背景色）
        const themeConfigs = {
            caramel: { name: '焦糖奶茶', bg: 'linear-gradient(135deg, #FDF8F3 0%, #F5EDE4 100%)' },
            matcha: { name: '抹茶清新', bg: 'linear-gradient(135deg, #F0F5F0 0%, #E0EBE0 100%)' },
            sakura: { name: '櫻花柔粉', bg: 'linear-gradient(135deg, #FFF5F5 0%, #FFE8E8 100%)' },
            fuji: { name: '藤紫優雅', bg: 'linear-gradient(135deg, #F8F5FC 0%, #EDE8F4 100%)' },
            orange: { name: '橘光日和', bg: 'linear-gradient(135deg, #FFF8F0 0%, #FFE8D8 100%)' },
            dark: { name: '夜空靜謐', bg: 'linear-gradient(135deg, #1A1A2E 0%, #16213E 100%)' }
        };

        const themes = ref([
            { id: 'orange', name: '橘光日和' },
            { id: 'caramel', name: '焦糖奶茶' },
            { id: 'matcha', name: '抹茶清新' },
            { id: 'sakura', name: '櫻花柔粉' },
            { id: 'fuji', name: '藤紫優雅' },
            { id: 'dark', name: '夜空靜謐' }
        ]);
        const currentTheme = ref(localStorage.getItem('smai-theme') || 'orange');

        // 套用主題背景
        const applyThemeBackground = (themeId) => {
            document.body.style.background = themeConfigs[themeId].bg;
        };

        // 初始化主題
        const initTheme = () => {
            const theme = currentTheme.value;
            if (theme !== 'caramel') {
                document.documentElement.setAttribute('data-theme', theme);
            }
            applyThemeBackground(theme);
        };

        // 設定主題
        const setTheme = (themeId) => {
            currentTheme.value = themeId;
            localStorage.setItem('smai-theme', themeId);
            if (themeId === 'caramel') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', themeId);
            }
            applyThemeBackground(themeId);
        };

        // 日夜切換
        const previousLightTheme = ref(localStorage.getItem('smai-light-theme') || 'orange');
        const toggleDarkMode = () => {
            if (currentTheme.value === 'dark') {
                // 切回日間模式
                setTheme(previousLightTheme.value);
            } else {
                // 記住當前主題，切換到深色
                previousLightTheme.value = currentTheme.value;
                localStorage.setItem('smai-light-theme', currentTheme.value);
                setTheme('dark');
            }
        };

        // 頁面載入時初始化主題
        initTheme();

        // 日本明星名字（隨機 placeholder）
        const jpStars = [
            '新垣結衣', '石原聰美', '綾瀨遙', '長澤雅美', '北川景子',
            '佐藤健', '菅田將暉', '山崎賢人', '吉澤亮', '橫濱流星',
            '廣瀨鈴', '有村架純', '川口春奈', '今田美櫻', '濱邊美波',
            '木村拓哉', '福山雅治', '玉木宏', '藤原龍也', '小栗旬'
        ];
        const randomStar = ref(jpStars[Math.floor(Math.random() * jpStars.length)]);

        // AI 助理訊息系統
        const aiMessages = {
            choice: [
                '這題考驗你的基礎知識，放輕鬆作答吧！',
                '仔細閱讀每個選項，答案就藏在細節裡',
                '相信你的直覺，但也別忘了驗證',
                '這題有點考驗細心度喔！'
            ],
            implement: [
                '實作題沒有標準答案，展現你的思路最重要',
                '可以用 AI 輔助，但記得說明你的理解',
                '寫出你的思考過程，這比答案更重要',
                '別只貼程式碼，解釋為什麼這樣做'
            ],
            review: [
                'Code Review 考驗你的觀察力和經驗',
                '試著找出潛在的 Bug 和改進空間',
                '好的 Code Review 能讓團隊一起進步',
                '想想如果這是你的程式碼，你會怎麼改？'
            ],
            personality: [
                '這題沒有對錯，誠實回答最重要',
                '我們想了解真實的你，不用猜我們想要什麼答案',
                '每個人都是獨一無二的，你的答案也是',
                '放鬆心情，想像真實情境會怎麼反應'
            ]
        };
        const aiMessage = computed(() => {
            const q = currentQuestion.value;
            if (!q.type) return '準備好了嗎？讓我們開始吧！';
            const category = q.category === '人格特質' ? 'personality' : q.type;
            const messages = aiMessages[category] || aiMessages.choice;
            // 根據題號選擇不同訊息
            return messages[currentQuestionIndex.value % messages.length];
        });

        // 倒數計時系統
        const timeLimit = 60; // 每題 60 秒
        const timeRemaining = ref(timeLimit);
        const timerInterval = ref(null);
        const timerProgress = computed(() => {
            return (timeRemaining.value / timeLimit) * 100;
        });
        const timerDanger = computed(() => timeRemaining.value <= 10);

        const startTimer = () => {
            stopTimer();
            timeRemaining.value = timeLimit;
            timerInterval.value = setInterval(() => {
                if (timeRemaining.value > 0) {
                    timeRemaining.value--;
                } else {
                    // 時間到自動跳下一題
                    nextQuestion();
                }
            }, 1000);
        };

        const stopTimer = () => {
            if (timerInterval.value) {
                clearInterval(timerInterval.value);
                timerInterval.value = null;
            }
        };

        // 行為追蹤系統
        const behaviorData = ref({
            responseTimes: [],        // 每題回答時間
            answerChanges: [],        // 每題更改答案次數
            startTime: null,          // 當題開始時間
            currentChangeCount: 0,    // 當題更改次數
            consecutiveCorrect: 0,    // 連續答對
            consecutiveWrong: 0       // 連續答錯
        });

        // 開始追蹤當題
        const startTracking = () => {
            behaviorData.value.startTime = Date.now();
            behaviorData.value.currentChangeCount = 0;
        };

        // 記錄答案變更
        const trackAnswerChange = () => {
            behaviorData.value.currentChangeCount++;
        };

        // 記錄當題完成
        const recordQuestionComplete = () => {
            const responseTime = (Date.now() - behaviorData.value.startTime) / 1000;
            behaviorData.value.responseTimes.push(responseTime);
            behaviorData.value.answerChanges.push(behaviorData.value.currentChangeCount);
        };

        // 計算行為統計
        const behaviorStats = computed(() => {
            const times = behaviorData.value.responseTimes;
            const changes = behaviorData.value.answerChanges;

            if (times.length === 0) {
                return {
                    avgResponseTime: 0,
                    totalChanges: 0,
                    correctRate: 0,
                    pattern: 'starting'
                };
            }

            const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
            const totalChanges = changes.reduce((a, b) => a + b, 0);

            // 計算目前正確率
            let correct = 0;
            let total = 0;
            currentQuestions.value.forEach((q, idx) => {
                if (q.type === 'choice' && answers.value[idx] !== undefined) {
                    total++;
                    if (answers.value[idx] === q.answer) correct++;
                }
            });

            const correctRate = total > 0 ? correct / total : 0;

            // 判斷行為模式
            let pattern = 'normal';
            if (avgTime < 15 && correctRate > 0.7) pattern = 'expert';
            else if (avgTime < 15 && correctRate < 0.5) pattern = 'rushing';
            else if (avgTime > 40) pattern = 'careful';
            else if (totalChanges > times.length * 0.5) pattern = 'hesitant';

            return {
                avgResponseTime: Math.round(avgTime),
                totalChanges,
                correctRate: Math.round(correctRate * 100),
                pattern,
                questionCount: times.length
            };
        });

        // 動態 AI 訊息（根據行為更新）
        const dynamicAiMessage = computed(() => {
            const stats = behaviorStats.value;
            const q = currentQuestion.value;

            if (!q.type) return '準備好了嗎？讓我們開始吧！';

            // 根據行為模式調整訊息
            if (stats.pattern === 'expert') {
                return '你的反應又快又準，真厲害！';
            } else if (stats.pattern === 'rushing') {
                return '慢一點沒關係，想清楚再選喔';
            } else if (stats.pattern === 'careful') {
                return '謹慎是好事，相信你的判斷';
            } else if (stats.pattern === 'hesitant') {
                return '相信你的第一直覺吧！';
            }

            // 預設訊息
            const category = q.category === '人格特質' ? 'personality' : q.type;
            const messages = aiMessages[category] || aiMessages.choice;
            return messages[currentQuestionIndex.value % messages.length];
        });

        // 鍵盤快捷鍵
        const setupKeyboardShortcuts = () => {
            document.addEventListener('keydown', (e) => {
                if (currentStep.value !== 'test') return;

                const q = currentQuestion.value;
                if (q.type === 'choice') {
                    // 1-4 選擇答案
                    if (e.key >= '1' && e.key <= '4') {
                        const idx = parseInt(e.key) - 1;
                        if (q.options && idx < q.options.length) {
                            answers.value[currentQuestionIndex.value] = idx;
                        }
                    }
                }

                // ← → 切換題目
                if (e.key === 'ArrowRight' || e.key === 'Enter') {
                    e.preventDefault();
                    nextQuestion();
                }
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    prevQuestion();
                }
            });
        };

        // 題目隨機排序
        const shuffleArray = (array) => {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        };

        // API URL
        const API_URL = 'https://smai-mcp-center.onrender.com/api/recruit';

        // Positions
        const positions = ref([
            {
                id: 'vue',
                name: 'Vue 前端工程師',
                tech: 'Vue 3, Tailwind CSS, DaisyUI',
                projects: ['GHG', 'MIDS', 'SSO', 'VAC', 'SMAI_8D', 'smai-process-vision', 'smai-ui'],
                jd: `【工作內容】
- 使用 Vue 3 Composition API 開發企業級應用
- 與 UI/UX 設計師協作，實現響應式介面
- 串接 RESTful API，處理前後端資料交換
- 維護現有專案，優化效能與使用者體驗

【必備條件】
- 熟悉 Vue 3、Tailwind CSS
- 了解 Git 版本控制
- 具備基本的 API 串接經驗

【加分條件】
- 有 DaisyUI、Shoelace 等 UI 框架經驗
- 了解 TypeScript
- 有 AI 輔助開發經驗`
            },
            {
                id: 'fullstack',
                name: '全端工程師 (Vite)',
                tech: 'Vite, Shoelace, Prisma, PostgreSQL',
                projects: ['MSW', 'EAP', 'RMS', 'BPM', 'RFID', 'MCS'],
                jd: `【工作內容】
- 負責前後端功能開發與整合
- 設計資料庫 Schema，使用 Prisma ORM
- 開發 RESTful API 並撰寫文件
- 參與系統架構設計與技術選型

【必備條件】
- 熟悉 JavaScript/TypeScript
- 了解 SQL 資料庫操作
- 具備前後端整合經驗

【加分條件】
- 有 Prisma、PostgreSQL 經驗
- 了解 Docker 容器化
- 有 CI/CD 經驗`
            },
            {
                id: 'angular',
                name: 'Angular 工程師',
                tech: 'Angular 21, PrimeNG, TypeScript',
                projects: ['MES'],
                jd: `【工作內容】
- 開發 MES 製造執行系統前端
- 使用 Angular 21 + PrimeNG 建構企業應用
- 與後端團隊協作，整合 API
- 參與 Code Review，維護程式碼品質

【必備條件】
- 熟悉 Angular 框架（版本 15+）
- 精通 TypeScript
- 了解 RxJS 響應式程式設計

【加分條件】
- 有 PrimeNG 經驗
- 了解製造業 MES 系統
- 有 Signals 經驗`
            },
            {
                id: 'python',
                name: 'Python 後端工程師',
                tech: 'FastAPI, SQLModel, PostgreSQL',
                projects: ['smai-mcp-center', 'API_Center'],
                jd: `【工作內容】
- 使用 FastAPI 開發高效能 API
- 設計資料庫模型，優化查詢效能
- 實作驗證授權機制
- 撰寫單元測試與 API 文件

【必備條件】
- 熟悉 Python 3.10+
- 了解 RESTful API 設計原則
- 具備 SQL 資料庫經驗

【加分條件】
- 有 FastAPI、SQLModel 經驗
- 了解 OAuth2、JWT
- 有 Docker 部署經驗`
            },
            {
                id: 'ai',
                name: 'AI/ML 工程師',
                tech: 'YOLO11, OpenCV, PyTorch',
                projects: ['AOI-8D', 'smai-process-vision', 'VisionAI'],
                jd: `【工作內容】
- 開發電腦視覺 AI 應用（AOI 瑕疵檢測）
- 訓練與優化 YOLO 物件偵測模型
- 處理影像資料集，進行資料增強
- 部署模型至邊緣裝置

【必備條件】
- 熟悉 Python、PyTorch/TensorFlow
- 了解電腦視覺基礎概念
- 具備模型訓練經驗

【加分條件】
- 有 YOLO 系列經驗
- 了解 OpenCV 影像處理
- 有邊緣運算部署經驗`
            },
            {
                id: 'devops',
                name: 'DevOps 工程師',
                tech: 'Docker, Shell, Python CLI',
                projects: ['dash-devtools', 'git-security-hooks', 'SSL'],
                jd: `【工作內容】
- 建置與維護 CI/CD Pipeline
- 開發自動化部署工具
- 管理容器化環境
- 監控系統效能與安全性

【必備條件】
- 熟悉 Linux 系統管理
- 了解 Docker 容器技術
- 具備 Shell Script 撰寫能力

【加分條件】
- 有 GitHub Actions 經驗
- 了解 Kubernetes
- 有 ISO 27001 相關經驗`
            },
            {
                id: 'iot',
                name: 'IoT 工程師',
                tech: 'PLC/HMI, Modbus TCP, MQTT, Node-RED',
                projects: ['WISE-IoT', 'ECU-4784', 'EdgeLink', 'OPC-UA'],
                jd: `【工作內容】
- 整合工業設備通訊（PLC、感測器）
- 開發 SCADA/HMI 人機介面
- 建置 IoT 資料採集系統
- 與 MES 系統整合

【必備條件】
- 了解工業通訊協定（Modbus、MQTT）
- 具備 PLC 程式設計經驗
- 熟悉電控迴路基礎

【加分條件】
- 有研華 WISE-IoT 平台經驗
- 了解 OPC-UA
- 有 Node-RED 經驗`
            }
        ]);

        // 基礎必備題（所有職位都要考）
        const coreQuestions = [
            {
                type: 'choice',
                difficulty: '基礎',
                category: 'Git',
                question: '以下哪個 Git 指令可以查看尚未提交的變更？',
                options: ['git log', 'git status', 'git show', 'git branch'],
                answer: 1
            },
            {
                type: 'choice',
                difficulty: '基礎',
                category: 'Git',
                question: '當你想要取消已經 git add 的檔案（unstage），應該用哪個指令？',
                options: ['git reset HEAD <file>', 'git checkout <file>', 'git revert <file>', 'git rm <file>'],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '中等',
                category: 'Git',
                question: '在團隊協作中，為什麼不建議對已經 push 的 commit 使用 git rebase？',
                options: [
                    '會改變 commit 歷史，造成其他人的分支衝突',
                    'rebase 比 merge 慢',
                    'rebase 會刪除檔案',
                    'GitHub 不支援 rebase'
                ],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '基礎',
                category: 'CI/CD',
                question: 'CI/CD 中的 CI 代表什麼？',
                options: ['Code Integration', 'Continuous Integration', 'Complete Installation', 'Central Infrastructure'],
                answer: 1
            },
            {
                type: 'choice',
                difficulty: '中等',
                category: 'CI/CD',
                question: '以下哪個不是 CI pipeline 常見的步驟？',
                options: ['Lint 檢查', '單元測試', '手動部署到正式環境', '建置 Docker image'],
                answer: 2
            },
            {
                type: 'implement',
                difficulty: '中等',
                category: 'Claude Code',
                question: '請描述你會如何使用 Claude Code（或其他 AI 工具）來協助開發一個新功能？從理解需求到完成實作的流程是什麼？請具體說明你會怎麼下 prompt、如何驗證 AI 產出的程式碼。',
                referenceAnswer: `參考答案重點：
1. 理解需求階段：先閱讀文件/PRD，用 AI 協助釐清模糊需求
2. 拆分任務：將大功能拆成小任務，每次給 AI 明確的小範圍
3. 提示技巧：提供上下文（現有程式碼結構）、明確輸入輸出、說明限制條件
4. 驗證方式：
   - 閱讀並理解 AI 產出的程式碼（不是直接複製貼上）
   - 檢查邊界條件和錯誤處理
   - 實際執行測試
   - Code review 後再 commit
5. 迭代改進：根據測試結果，請 AI 修正特定問題`
            },
            {
                type: 'review',
                difficulty: '中等',
                category: 'Claude Code',
                question: '以下是 AI 產生的程式碼，請指出可能的問題並說明你會如何驗證和改進它：',
                code: `// AI 產生的用戶驗證函數
function validateUser(input) {
    const user = JSON.parse(input)
    if (user.email.includes('@')) {
        return { valid: true, user }
    }
    return { valid: false }
}`,
                referenceAnswer: `主要問題：
1. JSON.parse 沒有 try-catch，無效 JSON 會拋出例外
2. user.email 可能不存在，會導致 undefined.includes() 錯誤
3. Email 驗證過於簡單，只檢查 @ 符號
4. 沒有檢查 user 物件是否為 null

改進方式：
function validateUser(input) {
    try {
        const user = JSON.parse(input)
        if (!user || typeof user.email !== 'string') {
            return { valid: false, error: '無效的用戶資料' }
        }
        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/
        if (!emailRegex.test(user.email)) {
            return { valid: false, error: 'Email 格式不正確' }
        }
        return { valid: true, user }
    } catch (e) {
        return { valid: false, error: '無效的 JSON 格式' }
    }
}`
            },
            // ============ 文件撰寫能力 ============
            {
                type: 'choice',
                difficulty: '基礎',
                category: '文件撰寫',
                question: '一份好的 API 文件應該包含哪些基本要素？',
                options: [
                    '端點路徑、HTTP 方法、請求/回應範例、錯誤碼說明',
                    '只需要端點路徑就夠了',
                    '程式碼註解就是最好的文件',
                    '口頭說明比文件更有效率'
                ],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '基礎',
                category: '文件撰寫',
                question: 'README.md 檔案的主要用途是什麼？',
                options: [
                    '專案說明、安裝步驟、使用方式、貢獻指南',
                    '記錄個人開發日誌',
                    '存放暫時的程式碼片段',
                    '只給主管看的進度報告'
                ],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '中等',
                category: '文件撰寫',
                question: '哪種工具常用於自動產生 API 文件？',
                options: [
                    'Swagger/OpenAPI',
                    'Microsoft Word',
                    'Notepad',
                    'Excel'
                ],
                answer: 0
            },
            // ============ 單元測試能力 ============
            {
                type: 'choice',
                difficulty: '基礎',
                category: '單元測試',
                question: '單元測試的主要目的是什麼？',
                options: [
                    '驗證單一函數或模組的行為是否符合預期',
                    '測試整個系統的效能',
                    '確認 UI 外觀正確',
                    '檢查資料庫連線'
                ],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '基礎',
                category: '單元測試',
                question: '測試金字塔（Test Pyramid）中，哪種測試應該數量最多？',
                options: [
                    '單元測試（Unit Tests）',
                    '整合測試（Integration Tests）',
                    'E2E 測試（End-to-End Tests）',
                    '手動測試'
                ],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '中等',
                category: '單元測試',
                question: '什麼是 Mock（模擬物件）？在測試中有什麼用途？',
                options: [
                    '模擬外部依賴（如 API、資料庫），讓測試可以獨立執行',
                    '一種新的程式語言',
                    '用來加速程式執行的工具',
                    '資料庫備份工具'
                ],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '中等',
                category: '單元測試',
                question: 'AAA 模式（Arrange-Act-Assert）是什麼？',
                options: [
                    '測試的結構模式：準備資料、執行動作、驗證結果',
                    '一種加密演算法',
                    '資料庫設計模式',
                    'API 認證方式'
                ],
                answer: 0
            },
            // ============ 系統測試能力 ============
            {
                type: 'choice',
                difficulty: '基礎',
                category: '系統測試',
                question: '整合測試（Integration Test）和單元測試的主要差異是什麼？',
                options: [
                    '整合測試驗證多個模組之間的互動，單元測試只測試單一模組',
                    '整合測試比較簡單，單元測試比較複雜',
                    '兩者完全相同',
                    '整合測試不需要寫程式碼'
                ],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '中等',
                category: '系統測試',
                question: 'E2E（End-to-End）測試的特點是什麼？',
                options: [
                    '模擬真實用戶操作，從前端到後端完整測試整個流程',
                    '只測試後端 API',
                    '只測試資料庫',
                    '只測試 CSS 樣式'
                ],
                answer: 0
            },
            {
                type: 'choice',
                difficulty: '中等',
                category: '系統測試',
                question: '哪種工具常用於前端 E2E 測試？',
                options: [
                    'Cypress 或 Playwright',
                    'Photoshop',
                    'Excel',
                    'Notepad'
                ],
                answer: 0
            },
            {
                type: 'implement',
                difficulty: '中等',
                category: '測試與文件',
                question: '假設你完成了一個「使用者登入」功能，請說明你會如何撰寫測試和文件？請包含：1) 會寫哪些單元測試案例 2) 會寫哪些整合測試 3) API 文件會包含什麼內容',
                referenceAnswer: `參考答案重點：

1. 單元測試案例：
   - 正確帳密應回傳成功
   - 錯誤密碼應回傳失敗
   - 不存在的帳號應回傳失敗
   - 空白帳密應回傳驗證錯誤
   - 密碼錯誤超過 N 次應鎖定帳號

2. 整合測試：
   - 測試實際資料庫連線
   - 測試 Session/JWT 產生
   - 測試登入後權限檢查

3. API 文件內容：
   - 端點：POST /api/auth/login
   - 請求格式：{ email, password }
   - 成功回應：{ token, user }
   - 錯誤回應：401, 400, 429
   - 使用範例（curl 或程式碼）`
            },
            // 人格特質題 - 正直善良
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你在測試時發現一個嚴重 Bug，但修復它會讓專案延遲一週。這時候你會怎麼做？',
                options: [
                    '立即向主管報告，誠實說明情況和影響',
                    '先自己嘗試修復，修不好再說',
                    '這不是我負責的模組，先不管',
                    '等客戶發現再處理'
                ],
                answer: 0,
                trait: 'integrity'
            },
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你的同事最近工作效率明顯下降，你私下知道他家裡有些困難。你會怎麼做？',
                options: [
                    '主動關心，問他需不需要幫忙分擔工作',
                    '這是私事，不應該過問',
                    '向主管反映他的工作表現',
                    '等他自己來求助'
                ],
                answer: 0,
                trait: 'kindness'
            },
            // 人格特質題 - 活潑大方
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '團隊要做技術分享，主管問誰願意當第一個講者，你會？',
                options: [
                    '主動舉手：「我來！正好最近研究了一個有趣的主題」',
                    '等別人先舉手，看情況再決定',
                    '假裝沒看到，希望不要點到我',
                    '表示最近太忙，下次再說'
                ],
                answer: 0,
                trait: 'outgoing'
            },
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '團隊聚餐時，你通常扮演什麼角色？',
                options: [
                    '活絡氣氛，主動找話題聊天',
                    '跟熟悉的人聊天就好',
                    '安靜吃飯，聽別人聊',
                    '能不去就不去'
                ],
                answer: 0,
                trait: 'outgoing'
            },
            // 人格特質題 - 願意分享
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你花了兩週研究出一個很厲害的解決方案，新來的同事遇到類似問題來問你，你會？',
                options: [
                    '詳細解釋原理，還把相關資料整理給他',
                    '簡單說明方向，讓他自己去研究',
                    '給他看我的程式碼，但不多解釋',
                    '告訴他去問 Google 或 ChatGPT'
                ],
                answer: 0,
                trait: 'sharing'
            },
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你發現一個能大幅提升效率的工具/技巧，你會怎麼做？',
                options: [
                    '寫一篇教學文或辦分享會，讓全團隊都知道',
                    '在群組裡簡單提一下',
                    '有人問再說',
                    '這是我的競爭優勢，先留著'
                ],
                answer: 0,
                trait: 'sharing'
            },
            // 綜合特質題
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你寫的程式碼被同事在 Code Review 中指出很多問題，你的反應是？',
                options: [
                    '感謝他的仔細審查，虛心接受並學習',
                    '解釋我為什麼這樣寫，但還是會改',
                    '覺得他太挑剔了',
                    '下次不想讓他 review 我的 code'
                ],
                answer: 0,
                trait: 'integrity'
            },
            {
                type: 'implement',
                difficulty: '情境',
                category: '人格特質',
                question: '請描述一個你曾經主動幫助同事或團隊的經驗。你做了什麼？為什麼這樣做？結果如何？',
                referenceAnswer: `評分重點：
1. 是否有具體的事例（不是空泛的描述）
2. 是否展現主動性（不是被要求才做）
3. 是否有同理心（理解他人的需求）
4. 結果導向（有正面的影響）

好的回答範例：
「新同事剛來時對專案架構不熟，我主動整理了一份架構說明文件，還約了一小時幫他導覽程式碼。後來他很快就能獨立作業，他說這份文件對他幫助很大，我也把文件放到團隊 Wiki 讓其他新人參考。」`,
                trait: 'comprehensive'
            },
            // 新增情境題 - 正直誠信
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你發現主管做了一個技術決策可能會造成未來的維護困難，你會怎麼做？',
                options: [
                    '私下向主管表達擔憂，提出具體的替代方案',
                    '主管說了算，照做就好',
                    '在會議上公開質疑主管的決定',
                    '等問題發生再說「我早就知道會這樣」'
                ],
                answer: 0,
                trait: 'integrity'
            },
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '專案快要上線了，你發現自己寫的功能還有一些邊緣案例沒處理完，但時間很趕。你會？',
                options: [
                    '誠實向團隊說明情況，討論是延期還是先上線再補',
                    '先上線，希望沒人發現這些問題',
                    '加班趕工，但不告訴任何人',
                    '這不是核心功能，應該沒關係'
                ],
                answer: 0,
                trait: 'integrity'
            },
            // 新增情境題 - 善解人意
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '新來的實習生問了一個你覺得很基礎的問題，你會？',
                options: [
                    '耐心解釋，並推薦一些學習資源',
                    '告訴他去看文件',
                    '嘆口氣，然後快速解答',
                    '心裡想「這也要問？」但還是回答了'
                ],
                answer: 0,
                trait: 'kindness'
            },
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '團隊成員因為私人因素請假，導致你需要臨時接手他的工作。你的反應是？',
                options: [
                    '理解他的狀況，主動接手並祝他好好休息',
                    '雖然有點煩，但還是會幫忙',
                    '向主管抱怨工作分配不公平',
                    '只做最基本的，其他的等他回來處理'
                ],
                answer: 0,
                trait: 'kindness'
            },
            // 新增情境題 - 活潑大方
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '公司舉辦 Hackathon，你會怎麼參與？',
                options: [
                    '積極組隊，主動找不同部門的人合作嘗試新想法',
                    '加入別人組的隊伍',
                    '觀望一下，看有沒有人來找我',
                    '工作已經夠忙了，這種活動就算了'
                ],
                answer: 0,
                trait: 'outgoing'
            },
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '部門來了一位新同事，第一天你會？',
                options: [
                    '主動自我介紹，帶他認識環境和其他同事',
                    '等主管介紹的時候再打招呼',
                    '點頭微笑，繼續做自己的事',
                    '等他來問我問題再說'
                ],
                answer: 0,
                trait: 'outgoing'
            },
            // 新增情境題 - 願意分享
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你解決了一個困擾團隊很久的技術問題，你會？',
                options: [
                    '寫一份詳細的解決方案文件，在團隊會議上分享',
                    '在群組裡簡單說一下解法',
                    '有人問再告訴他',
                    '默默解決就好，不用特別說'
                ],
                answer: 0,
                trait: 'sharing'
            },
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你參加了一個很棒的技術研討會，回來後你會？',
                options: [
                    '整理筆記，主動辦一場內部分享會',
                    '在群組分享幾個重點',
                    '有人問再說',
                    '吸收消化就好，不需要特別分享'
                ],
                answer: 0,
                trait: 'sharing'
            },
            // 新增情境題 - 綜合情境
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '專案延期了，主管問責任歸屬。事實上是因為需求一直在變，你會怎麼說？',
                options: [
                    '客觀說明：需求變更頻繁是主因，但我們也可以改進估算方式',
                    '說是需求變更的問題，不關我的事',
                    '不想惹事，說是我自己估算錯誤',
                    '保持沉默，讓別人去解釋'
                ],
                answer: 0,
                trait: 'integrity'
            },
            {
                type: 'choice',
                difficulty: '情境',
                category: '人格特質',
                question: '你注意到團隊的開發流程有可以優化的地方，你會？',
                options: [
                    '收集數據，準備改善提案在團隊會議上討論',
                    '私下跟主管提一下',
                    '這不是我的職責範圍',
                    '反正講了也不會改'
                ],
                answer: 0,
                trait: 'sharing'
            }
        ];

        // Question Banks
        const questionBanks = {
            vue: [
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'Vue 3 的 Composition API 中，哪個函數用於建立響應式物件？',
                    options: ['ref()', 'reactive()', 'computed()', '以上皆是'],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: '在 Vue 3 中，watch 和 watchEffect 的主要差別是？',
                    options: [
                        'watch 需要明確指定監聽的響應式資料',
                        'watchEffect 會自動追蹤依賴',
                        'watch 可以取得新舊值',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    question: 'Tailwind CSS 的 JIT (Just-in-Time) 模式有什麼優點？',
                    options: [
                        '只產生用到的 CSS，檔案更小',
                        '支援任意值如 w-[123px]',
                        '開發時更快編譯',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'review',
                    difficulty: '中等',
                    question: '以下 Vue 3 程式碼有什麼問題？請指出並說明如何修正。',
                    code: `const count = ref(0)
const doubled = count.value * 2  // 希望是響應式的雙倍值

function increment() {
    count = count.value + 1
}`,
                    referenceAnswer: `問題：
1. doubled 只計算一次，不是響應式的（應該用 computed）
2. increment 中直接賦值給 count，應該用 count.value

修正：
const count = ref(0)
const doubled = computed(() => count.value * 2)

function increment() {
    count.value++  // 或 count.value = count.value + 1
}`
                },
                {
                    type: 'implement',
                    difficulty: '進階',
                    question: '請實作一個 Vue 3 composable 函數 useDebounce(value, delay)，將輸入值防抖處理。說明你的實作思路。',
                    referenceAnswer: `import { ref, watch } from 'vue'

export function useDebounce(value, delay = 300) {
    const debouncedValue = ref(value.value)
    let timer = null

    watch(value, (newVal) => {
        if (timer) clearTimeout(timer)
        timer = setTimeout(() => {
            debouncedValue.value = newVal
        }, delay)
    })

    return debouncedValue
}

// 使用方式：
// const searchText = ref('')
// const debouncedSearch = useDebounce(searchText, 500)`
                },
                // Vue 測試相關
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Vue 測試',
                    question: 'Vue 3 官方推薦使用哪個測試框架進行單元測試？',
                    options: [
                        'Vitest',
                        'Mocha',
                        'Jasmine',
                        'QUnit'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Vue 測試',
                    question: '@vue/test-utils 的 mount() 和 shallowMount() 有什麼差別？',
                    options: [
                        'mount 會渲染子組件，shallowMount 只渲染當前組件（子組件為 stub）',
                        '兩者完全相同',
                        'shallowMount 比較慢',
                        'mount 不支援 props'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Vue 文件',
                    question: '哪個工具可以用來為 Vue 組件建立互動式文件和視覺測試？',
                    options: [
                        'Storybook',
                        'Word',
                        'Notepad',
                        'Paint'
                    ],
                    answer: 0
                }
            ],
            fullstack: [
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'Prisma 中，哪個指令用於同步資料庫 schema？',
                    options: ['prisma generate', 'prisma migrate dev', 'prisma db push', 'prisma sync'],
                    answer: 2
                },
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'Vite 相比 Webpack 的主要優勢是？',
                    options: [
                        '開發時使用原生 ES modules，啟動更快',
                        '生產環境用 Rollup 打包',
                        'HMR 更新更快',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    question: 'Shoelace Web Components 的優點是？',
                    options: [
                        '框架無關，可用於 Vue/React/Angular',
                        '原生瀏覽器支援，不需要編譯',
                        '樣式封裝在 Shadow DOM',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'review',
                    difficulty: '中等',
                    question: '以下 Prisma query 有什麼效能問題？如何優化？',
                    code: `// 取得所有用戶和他們的訂單
const users = await prisma.user.findMany()
for (const user of users) {
    const orders = await prisma.order.findMany({
        where: { userId: user.id }
    })
    user.orders = orders
}`,
                    referenceAnswer: `問題：N+1 查詢問題
- 第一次查詢所有用戶（1 次）
- 每個用戶再查一次訂單（N 次）
- 若有 100 個用戶，就會執行 101 次查詢

優化方式：使用 Prisma 的 include 關聯查詢
const users = await prisma.user.findMany({
    include: {
        orders: true
    }
})
// 只需 1 次查詢，Prisma 會用 JOIN 或子查詢處理`
                },
                {
                    type: 'implement',
                    difficulty: '進階',
                    question: '請設計一個 RESTful API 端點來處理分頁查詢，需支援排序、篩選功能。說明 URL 設計和回傳格式。',
                    referenceAnswer: `URL 設計：
GET /api/products?page=1&limit=20&sort=price:desc&filter[category]=electronics

回傳格式：
{
    "success": true,
    "data": [...],
    "pagination": {
        "page": 1,
        "limit": 20,
        "total": 150,
        "totalPages": 8,
        "hasNext": true,
        "hasPrev": false
    }
}

重點：
1. 分頁用 page + limit（或 offset）
2. 排序用 sort=field:direction
3. 篩選用 filter[field]=value
4. 回傳 total 讓前端知道總筆數`
                },
                // Fullstack 測試相關
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: '全端測試',
                    question: 'Prisma 的測試最佳實踐是什麼？',
                    options: [
                        '使用測試資料庫，每次測試前清空資料',
                        '直接測試正式資料庫',
                        '不需要測試資料庫操作',
                        '只用 console.log 檢查'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: '全端文件',
                    question: 'OpenAPI (Swagger) 規範的主要用途是？',
                    options: [
                        '標準化 RESTful API 的描述格式，可自動產生文件和客戶端程式碼',
                        '資料庫設計工具',
                        '前端 UI 框架',
                        '版本控制系統'
                    ],
                    answer: 0
                }
            ],
            angular: [
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'Angular 的 Standalone Components 有什麼優點？',
                    options: [
                        '不需要 NgModule',
                        '更容易做 tree-shaking',
                        '簡化應用結構',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'Angular Signals 是用來做什麼的？',
                    options: [
                        '取代 RxJS 做簡單的狀態管理',
                        '更細粒度的變更偵測',
                        '提升效能',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    question: 'PrimeNG 的 p-table 元件，如何實現伺服器端分頁？',
                    options: [
                        '設定 lazy="true" 並監聽 onLazyLoad 事件',
                        '使用 paginator 屬性',
                        '使用 virtualScroll',
                        '設定 rows 屬性'
                    ],
                    answer: 0
                },
                {
                    type: 'review',
                    difficulty: '中等',
                    question: '以下 Angular 程式碼有什麼問題？',
                    code: `@Component({
    selector: 'app-user',
    template: \`<div>{{ user.name }}</div>\`
})
export class UserComponent {
    @Input() user: User;

    ngOnInit() {
        console.log(this.user.name);  // 可能出錯
    }
}`,
                    referenceAnswer: `問題：
1. @Input() user 在 ngOnInit 時可能還沒有值（undefined）
2. 應該用 ngOnChanges 或設定初始值

修正方式 1：使用 required input (Angular 16+)
@Input({ required: true }) user!: User;

修正方式 2：用 ngOnChanges
ngOnChanges(changes: SimpleChanges) {
    if (changes['user']?.currentValue) {
        console.log(this.user.name);
    }
}

修正方式 3：用 setter
private _user: User;
@Input() set user(value: User) {
    this._user = value;
    if (value) console.log(value.name);
}`
                },
                {
                    type: 'implement',
                    difficulty: '進階',
                    question: '請說明如何在 Angular 中實作一個可重用的確認對話框服務 (ConfirmationService)，支援 Promise-based API。',
                    referenceAnswer: `// confirmation.service.ts
@Injectable({ providedIn: 'root' })
export class ConfirmationService {
    constructor(private dialog: MatDialog) {}  // 或用 PrimeNG

    confirm(message: string, title = '確認'): Promise<boolean> {
        const dialogRef = this.dialog.open(ConfirmDialogComponent, {
            data: { title, message }
        });
        return firstValueFrom(dialogRef.afterClosed());
    }
}

// 使用方式：
async deleteItem() {
    const confirmed = await this.confirmService.confirm(
        '確定要刪除此項目嗎？'
    );
    if (confirmed) {
        // 執行刪除
    }
}`
                },
                // Angular 測試相關
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Angular 測試',
                    question: 'Angular 預設使用哪個測試框架？',
                    options: [
                        'Jasmine + Karma',
                        'Jest',
                        'Mocha',
                        'QUnit'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Angular 測試',
                    question: 'Angular 的 TestBed 主要用途是什麼？',
                    options: [
                        '設定測試模組，提供依賴注入環境',
                        '資料庫測試工具',
                        'CSS 測試工具',
                        '效能測試工具'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Angular 文件',
                    question: 'Compodoc 是用來做什麼的？',
                    options: [
                        '自動產生 Angular 專案的文件',
                        '編譯 Angular 程式碼',
                        '資料庫遷移工具',
                        '打包工具'
                    ],
                    answer: 0
                }
            ],
            python: [
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'FastAPI 的 Depends 函數主要用途是？',
                    options: ['依賴注入', '路由定義', '錯誤處理', '資料驗證'],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'SQLModel 結合了哪兩個套件的功能？',
                    options: [
                        'SQLAlchemy + Pydantic',
                        'Django ORM + Marshmallow',
                        'Peewee + attrs',
                        'Tortoise + dataclasses'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    question: 'FastAPI 中如何正確處理資料庫 session 的生命週期？',
                    options: [
                        '使用 Depends 和 generator function (yield)',
                        '在每個 route 手動建立和關閉',
                        '使用全域 session',
                        '使用 middleware'
                    ],
                    answer: 0
                },
                {
                    type: 'review',
                    difficulty: '中等',
                    question: '以下 FastAPI 程式碼有什麼安全性問題？',
                    code: `@app.get("/users/{user_id}")
async def get_user(user_id: str, db: Session = Depends(get_db)):
    query = f"SELECT * FROM users WHERE id = '{user_id}'"
    result = db.execute(query)
    return result.fetchone()`,
                    referenceAnswer: `問題：SQL Injection 漏洞
攻擊者可以輸入: 1' OR '1'='1
變成: SELECT * FROM users WHERE id = '1' OR '1'='1'
會取得所有用戶資料

修正方式：使用參數化查詢
from sqlalchemy import text

@app.get("/users/{user_id}")
async def get_user(user_id: str, db: Session = Depends(get_db)):
    query = text("SELECT * FROM users WHERE id = :user_id")
    result = db.execute(query, {"user_id": user_id})
    return result.fetchone()

更好的方式：使用 ORM
user = db.query(User).filter(User.id == user_id).first()`
                },
                {
                    type: 'implement',
                    difficulty: '進階',
                    question: '請實作一個 FastAPI 的 BackgroundTasks 範例，用於在 API 回應後異步發送 Email。說明為什麼要用 BackgroundTasks 而不是直接等待。',
                    referenceAnswer: `from fastapi import BackgroundTasks

def send_email(email: str, subject: str, body: str):
    # 模擬耗時的 Email 發送
    import time
    time.sleep(3)  # SMTP 連線、發送可能要幾秒
    print(f"Email sent to {email}")

@app.post("/register")
async def register(
    user: UserCreate,
    background_tasks: BackgroundTasks
):
    # 1. 建立用戶（快速完成）
    new_user = create_user(user)

    # 2. 背景發送歡迎信（不阻塞回應）
    background_tasks.add_task(
        send_email,
        user.email,
        "歡迎加入",
        "感謝您的註冊..."
    )

    # 3. 立即回應（不等 Email）
    return {"message": "註冊成功", "user_id": new_user.id}

為什麼用 BackgroundTasks：
- API 回應更快（不等 Email）
- 用戶體驗更好
- Email 失敗不影響註冊結果`
                },
                // Python 測試相關
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Python 測試',
                    question: 'Python 最常用的測試框架是？',
                    options: [
                        'pytest',
                        'unittest',
                        'nose',
                        '以上都常用，但 pytest 最流行'
                    ],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Python 測試',
                    question: 'FastAPI 的 TestClient 是基於哪個套件？',
                    options: [
                        'httpx (Starlette TestClient)',
                        'requests',
                        'urllib',
                        'aiohttp'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Python 文件',
                    question: '哪個工具可以自動產生 Python API 文件？',
                    options: [
                        'Sphinx 或 MkDocs',
                        'Word',
                        'Notepad',
                        'Excel'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'Python 文件',
                    question: 'FastAPI 內建支援自動產生什麼格式的 API 文件？',
                    options: [
                        'OpenAPI (Swagger UI) 和 ReDoc',
                        '只有 PDF',
                        '只有 Word',
                        '不支援自動產生文件'
                    ],
                    answer: 0
                }
            ],
            ai: [
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'YOLO (You Only Look Once) 的主要特點是？',
                    options: [
                        '單次前向傳播同時預測所有物件',
                        '即時物件偵測',
                        '端到端訓練',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'OpenCV 中 cv2.VideoCapture 的 read() 方法回傳什麼？',
                    options: [
                        '只有影格 (frame)',
                        '(成功旗標, 影格)',
                        '影片資訊',
                        '影格數量'
                    ],
                    answer: 1
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    question: '物件偵測中，IoU (Intersection over Union) 的用途是？',
                    options: [
                        '評估預測框和真實框的重疊程度',
                        '用於 NMS (Non-Maximum Suppression)',
                        '計算模型準確率 (mAP)',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'review',
                    difficulty: '中等',
                    question: '以下程式碼在處理影片時可能有什麼問題？',
                    code: `cap = cv2.VideoCapture(video_path)
frames = []
while True:
    ret, frame = cap.read()
    if not ret:
        break
    frames.append(frame)  # 儲存所有影格
# 處理 frames...`,
                    referenceAnswer: `問題：記憶體溢出 (OOM)
- 1080p 影格約 6MB
- 30fps 影片 1 分鐘 = 1800 影格 = 10.8GB
- 長影片會耗盡記憶體

修正方式 1：邊讀邊處理
while True:
    ret, frame = cap.read()
    if not ret:
        break
    process_frame(frame)  # 立即處理，不存

修正方式 2：只存關鍵幀
if frame_count % 30 == 0:  # 每秒取一幀
    frames.append(frame)

修正方式 3：用 generator
def frame_generator(cap):
    while True:
        ret, frame = cap.read()
        if not ret:
            break
        yield frame`
                },
                {
                    type: 'implement',
                    difficulty: '進階',
                    question: '請說明如何用 YOLO 實作一個簡單的製程動作分段系統：給定一段作業員操作影片，如何偵測並標記不同的動作階段？',
                    referenceAnswer: `架構設計：
1. 物件偵測層：用 YOLO 偵測人體/手部/工具
2. 動作識別層：根據物件位置變化判斷動作
3. 分段邏輯：狀態機判斷動作切換

實作步驟：
1. 訓練 YOLO 偵測：工具、產品、手部
2. 追蹤物件軌跡（用 DeepSORT）
3. 定義動作規則：
   - 手接近工具 → 取料
   - 工具接近產品 → 加工
   - 手離開工具 → 放料
4. 時間序列平滑（避免誤判）

輸出格式：
[
    {"start": 0, "end": 5.2, "action": "取料"},
    {"start": 5.2, "end": 12.8, "action": "加工"},
    ...
]`
                },
                // AI/ML 測試相關
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'AI 測試',
                    question: '模型評估時，Precision（精確率）和 Recall（召回率）的差別是？',
                    options: [
                        'Precision 關注預測正確的比例，Recall 關注實際正例被找到的比例',
                        '兩者完全相同',
                        'Precision 越高越好，Recall 不重要',
                        '只有分類問題才需要這些指標'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'AI 測試',
                    question: 'A/B 測試在 AI 模型部署中的用途是？',
                    options: [
                        '比較新舊模型在真實環境的效果',
                        '訓練模型用的',
                        '資料清洗用的',
                        '只是一種命名慣例'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'AI 文件',
                    question: '好的 AI 模型文件應該包含什麼？',
                    options: [
                        '訓練資料描述、模型架構、評估指標、使用限制',
                        '只需要程式碼就夠了',
                        '只需要 accuracy 數字',
                        '不需要文件，模型會自己說明'
                    ],
                    answer: 0
                }
            ],
            devops: [
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'Docker 的 multi-stage build 有什麼好處？',
                    options: [
                        '減少最終映像檔大小',
                        '分離建置環境和執行環境',
                        '不需要在執行環境安裝建置工具',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'Git hook 中，pre-commit 和 pre-push 的差別是？',
                    options: [
                        'pre-commit 在 commit 前執行，pre-push 在 push 前執行',
                        'pre-commit 檢查單次變更，pre-push 可檢查多個 commits',
                        'pre-push 可以阻止推送到遠端',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    question: '以下哪個做法可以避免在 Git 中不小心提交機敏資料？',
                    options: [
                        '使用 .gitignore 忽略 .env 檔案',
                        '使用 pre-commit hook 掃描機敏資料',
                        '使用 git-secrets 或類似工具',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'review',
                    difficulty: '中等',
                    question: '以下 Dockerfile 有什麼可以改進的地方？',
                    code: `FROM python:3.12
WORKDIR /app
COPY . .
RUN pip install -r requirements.txt
CMD ["python", "app.py"]`,
                    referenceAnswer: `改進點：
1. 沒用 multi-stage build（映像檔太大）
2. COPY . . 會複製不需要的檔案（應加 .dockerignore）
3. requirements.txt 應該先複製（利用快取）
4. 沒有指定 slim 版本

優化版本：
FROM python:3.12-slim AS builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

FROM python:3.12-slim
WORKDIR /app
COPY --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages
COPY app.py .
CMD ["python", "app.py"]

重點：
- 用 slim 版本減少大小
- 分階段減少最終映像檔大小
- 先複製 requirements.txt 利用快取`
                },
                {
                    type: 'implement',
                    difficulty: '進階',
                    question: '請設計一個 CI/CD pipeline，當 push 到 main branch 時自動：1) 執行測試 2) 建置 Docker image 3) 部署到 staging 環境。說明你會用什麼工具和為什麼。',
                    referenceAnswer: `工具選擇：GitHub Actions（與 GitHub 整合最好）

.github/workflows/deploy.yml:
name: Deploy to Staging
on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: npm install && npm test

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: docker/build-push-action@v5
        with:
          push: true
          tags: ghcr.io/\${{ github.repository }}:staging

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Render/Vercel
        run: curl -X POST \${{ secrets.DEPLOY_WEBHOOK }}

為什麼這樣設計：
- test 失敗就不會建置
- 用 needs 確保順序
- 用 secrets 保護敏感資訊`
                },
                // DevOps 測試相關
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'DevOps 測試',
                    question: 'CI/CD Pipeline 中的測試階段通常包含哪些？',
                    options: [
                        '單元測試、整合測試、E2E 測試、安全掃描',
                        '只需要手動測試',
                        '不需要測試，直接部署',
                        '只需要 Lint 檢查'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'DevOps 測試',
                    question: '什麼是 Smoke Test（冒煙測試）？',
                    options: [
                        '部署後快速驗證核心功能是否正常運作',
                        '測試系統會不會冒煙',
                        '壓力測試的另一種說法',
                        '資安滲透測試'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'DevOps 文件',
                    question: 'Infrastructure as Code (IaC) 文件的好處是？',
                    options: [
                        '基礎設施設定可版本控制、可重現、可審核',
                        '只是另一種文件格式',
                        '用來寫程式文件的',
                        '只有大公司才需要'
                    ],
                    answer: 0
                }
            ],
            iot: [
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: '研華 WISE-IoT 平台中，EdgeLink 的主要用途是什麼？',
                    options: [
                        '雲端資料儲存',
                        '邊緣端資料擷取與協議轉換',
                        '網頁前端開發',
                        '資料庫管理'
                    ],
                    answer: 1
                },
                {
                    type: 'choice',
                    difficulty: '基礎',
                    question: 'Modbus RTU 和 Modbus TCP 的主要差別是？',
                    options: [
                        'RTU 使用序列通訊，TCP 使用乙太網路',
                        'RTU 速度較快',
                        'TCP 不需要設定站號',
                        'RTU 只能讀取，TCP 可讀寫'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    question: 'Node-RED 中，如何處理 MQTT 訊息並轉發到 HTTP API？',
                    options: [
                        '使用 mqtt in → function → http request 節點',
                        '直接用 mqtt out 節點',
                        '需要寫 Python 腳本',
                        '無法實現'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    question: 'OPC UA 相較於傳統 OPC DA 的優勢是？',
                    options: [
                        '跨平台支援（不限於 Windows）',
                        '內建安全機制',
                        '支援資訊模型',
                        '以上皆是'
                    ],
                    answer: 3
                },
                {
                    type: 'review',
                    difficulty: '中等',
                    question: '以下 Node-RED flow 有什麼問題？如何改進？',
                    code: `mqtt in [broker]
  → function (每秒處理 100 筆)
    → http request (POST 到 API)
// 問題：API 回應緩慢時會發生什麼？`,
                    referenceAnswer: `問題：背壓 (Backpressure)
- 每秒 100 筆 MQTT 訊息進來
- 但 HTTP API 回應要 200ms
- 5 秒後就會堆積 500 個待處理請求
- 最終記憶體爆掉或訊息丟失

改進方式：
1. 批次處理：
   delay node (rate limit: 10 msg/s)
   → join node (combine 10 msgs)
   → http request (batch POST)

2. 加入佇列：
   mqtt in → queue node → http request
   （使用 node-red-contrib-queue-gate）

3. 本地快取：
   mqtt in → function (寫入 SQLite)
   定時 → 批次送 API

4. 監控警報：
   監控 queue 長度，超過閾值發警報`
                },
                {
                    type: 'implement',
                    difficulty: '進階',
                    question: '請設計一個工廠設備監控系統架構：如何從 PLC (Modbus) 擷取資料，經過邊緣運算 (WISE-IoT/EdgeLink)，最後呈現在網頁儀表板？請說明資料流和每層的技術選擇。',
                    referenceAnswer: `系統架構（由下到上）：

1. 設備層 (Field Level)
   - PLC: Siemens S7 / 三菱 / 歐姆龍
   - 協議: Modbus TCP (最常見)
   - 資料: 溫度、壓力、轉速、產量

2. 邊緣層 (Edge Level)
   - 硬體: 研華 ECU-4784 / UNO-2484G
   - 軟體: EdgeLink (協議轉換)
   - 功能:
     * Modbus → MQTT 轉換
     * 資料預處理（過濾雜訊）
     * 本地快取（斷網續傳）

3. 傳輸層 (Transport)
   - 協議: MQTT (輕量、可靠)
   - Broker: EMQX / Mosquitto
   - 格式: JSON

4. 應用層 (Application)
   - 後端: FastAPI + PostgreSQL
   - 時序資料: InfluxDB / TimescaleDB
   - 前端: Vue 3 + ECharts

5. 資料流:
   PLC → Modbus TCP → EdgeLink → MQTT → API → DB → Dashboard

關鍵設計：
- 邊緣快取避免資料丟失
- MQTT QoS 1 確保送達
- 時序資料庫處理大量寫入`
                },
                // IoT 測試相關
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'IoT 測試',
                    question: 'IoT 系統的硬體整合測試（HIL）主要測試什麼？',
                    options: [
                        '軟體與實際硬體的互動是否正常',
                        '只測試軟體邏輯',
                        '只測試 UI 外觀',
                        '只測試資料庫'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'IoT 測試',
                    question: '如何測試 MQTT 通訊是否正常？',
                    options: [
                        '使用 MQTT 客戶端工具（如 MQTT Explorer）訂閱並檢查訊息',
                        '只看程式碼就知道了',
                        '不需要測試通訊',
                        '只測試資料庫'
                    ],
                    answer: 0
                },
                {
                    type: 'choice',
                    difficulty: '中等',
                    category: 'IoT 文件',
                    question: 'IoT 專案的技術文件應該包含什麼？',
                    options: [
                        '硬體接線圖、通訊協定規格、資料格式、系統架構圖',
                        '只需要程式碼就夠了',
                        '只需要 UI 截圖',
                        '不需要文件'
                    ],
                    answer: 0
                }
            ]
        };

        // Computed
        const currentQuestions = computed(() => {
            // 優先使用洗牌後的題目
            if (shuffledQuestions.value.length > 0) {
                return shuffledQuestions.value;
            }
            // 尚未開始測驗時返回原始題目列表（用於顯示題數等）
            if (!selectedPosition.value) return [];
            const positionQuestions = questionBanks[selectedPosition.value.id] || [];
            return [...coreQuestions, ...positionQuestions];
        });

        const currentQuestion = computed(() => {
            return currentQuestions.value[currentQuestionIndex.value] || {};
        });

        const choiceScore = computed(() => {
            let score = 0;
            currentQuestions.value.forEach((q, idx) => {
                if (q.type === 'choice' && answers.value[idx] === q.answer) {
                    score++;
                }
            });
            return score;
        });

        const totalChoiceQuestions = computed(() => {
            return currentQuestions.value.filter(q => q.type === 'choice').length;
        });

        // 人格特質分數計算
        const personalityScores = computed(() => {
            const scores = {
                integrity: { score: 0, total: 0, label: '正直善良' },
                kindness: { score: 0, total: 0, label: '善解人意' },
                outgoing: { score: 0, total: 0, label: '活潑大方' },
                sharing: { score: 0, total: 0, label: '願意分享' }
            };
            currentQuestions.value.forEach((q, idx) => {
                if (q.trait && scores[q.trait] && q.type === 'choice') {
                    scores[q.trait].total++;
                    if (answers.value[idx] === q.answer) {
                        scores[q.trait].score++;
                    }
                }
            });
            return scores;
        });

        // 結果頁鼓勵訊息
        const resultEncouragement = computed(() => {
            const rate = totalChoiceQuestions.value > 0 ? choiceScore.value / totalChoiceQuestions.value : 0;
            if (rate >= 0.8) {
                return {
                    alertClass: 'alert-success',
                    icon: 'M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z',
                    message: '太厲害了！你的表現非常優秀，期待與你共事！'
                };
            } else if (rate >= 0.6) {
                return {
                    alertClass: 'alert-info',
                    icon: 'M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
                    message: '表現不錯！我們會仔細評估你的答案，很快與你聯繫。'
                };
            } else if (rate >= 0.4) {
                return {
                    alertClass: 'alert-warning',
                    icon: 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z',
                    message: '感謝你的參與！技術題只是評估的一部分，我們更重視你的思路和態度。'
                };
            } else {
                return {
                    alertClass: 'alert-warning',
                    icon: 'M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z',
                    message: '沒關係！每個人都有自己的強項，我們會綜合評估你的潛力和特質。保持學習的熱情最重要！'
                };
            }
        });

        // 洗牌函數 (Fisher-Yates)
        const shuffleArray = (array) => {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        };

        // 洗牌題目選項
        const shuffleQuestionOptions = (questions) => {
            return questions.map(q => {
                if (q.type !== 'choice' || !q.options) return q;

                // 創建索引映射: [原索引, 選項內容]
                const indexed = q.options.map((opt, i) => ({ idx: i, opt }));
                const shuffled = shuffleArray(indexed);

                // 找到正確答案的新位置
                const newAnswer = shuffled.findIndex(item => item.idx === q.answer);

                return {
                    ...q,
                    options: shuffled.map(item => item.opt),
                    answer: newAnswer, // 更新正確答案索引
                    originalAnswer: q.answer // 保留原始答案索引供 debug
                };
            });
        };

        // Methods
        const startTest = () => {
            currentStep.value = 'test';
            currentQuestionIndex.value = 0;
            answers.value = {};

            // 洗牌題目選項
            const questions = [...coreQuestions, ...(questionBanks[selectedPosition.value.id] || [])];
            shuffledQuestions.value = shuffleQuestionOptions(questions);

            // 重置行為追蹤
            behaviorData.value = {
                responseTimes: [],
                answerChanges: [],
                startTime: null,
                currentChangeCount: 0,
                consecutiveCorrect: 0,
                consecutiveWrong: 0
            };
            startTimer();
            startTracking();
            setupKeyboardShortcuts();
        };

        const nextQuestion = () => {
            if (currentQuestionIndex.value < currentQuestions.value.length - 1) {
                recordQuestionComplete(); // 記錄當題行為
                currentQuestionIndex.value++;
                startTimer();
                startTracking(); // 開始追蹤下一題
            }
        };

        const prevQuestion = () => {
            if (currentQuestionIndex.value > 0) {
                currentQuestionIndex.value--;
                startTimer();
                startTracking();
            }
        };

        // 生成進階挑戰題
        const generateChallengeQuestions = async () => {
            isGeneratingChallenge.value = true;
            challengeError.value = '';
            challengeQuestions.value = [];

            try {
                const previousQs = currentQuestions.value.map(q => q.question);
                const stats = behaviorStats.value;

                // 生成 2 題
                for (let i = 0; i < 2; i++) {
                    const response = await fetch('/api/generate-question', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            position: selectedPosition.value.id,
                            behavior: {
                                avgResponseTime: stats.avgResponseTime,
                                correctRate: stats.correctRate / 100,
                                changeCount: stats.totalChanges,
                                questionCount: stats.questionCount
                            },
                            previousQuestions: [...previousQs, ...challengeQuestions.value.map(q => q.question)],
                            difficulty: stats.correctRate > 70 ? '進階' : '中等'
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.question) {
                            challengeQuestions.value.push({
                                ...data.question,
                                isChallenge: true
                            });
                        }
                    }
                }

                // 如果成功生成至少一題，進入挑戰模式
                if (challengeQuestions.value.length > 0) {
                    currentChallengeIndex.value = 0;
                    currentStep.value = 'challenge';
                    startTimer();
                } else {
                    // 沒有生成成功，直接到結果
                    await finalSubmit();
                }
            } catch (err) {
                console.error('Generate challenge error:', err);
                challengeError.value = '無法生成進階題目';
                // 失敗也繼續到結果
                await finalSubmit();
            } finally {
                isGeneratingChallenge.value = false;
            }
        };

        // 進入挑戰題流程
        const submitTest = async () => {
            stopTimer();
            recordQuestionComplete();
            // 先嘗試生成挑戰題
            await generateChallengeQuestions();
        };

        // 最終提交
        const finalSubmit = async () => {
            isSubmitting.value = true;
            submitError.value = '';

            try {
                // 人格特質分析
                const personalityAnalysis = {};
                for (const [key, trait] of Object.entries(personalityScores.value)) {
                    personalityAnalysis[key] = {
                        label: trait.label,
                        score: trait.score,
                        total: trait.total,
                        percentage: trait.total > 0 ? Math.round(trait.score / trait.total * 100) : 0
                    };
                }

                // 組裝答案資料
                const answersData = currentQuestions.value.map((q, idx) => ({
                    question: q.question,
                    type: q.type,
                    category: q.category || selectedPosition.value.name,
                    answer: q.type === 'choice' ? q.options[answers.value[idx]] : answers.value[idx],
                    correct: q.type === 'choice' ? answers.value[idx] === q.answer : null,
                    trait: q.trait || null
                }));

                // 挑戰題答案
                const challengeData = challengeQuestions.value.map((q, idx) => ({
                    question: q.question,
                    category: q.category || '進階挑戰',
                    answer: q.options ? q.options[challengeAnswers.value[idx]] : challengeAnswers.value[idx]
                }));

                // 提交到後端 (使用 snake_case)
                const response = await fetch(`${API_URL}/submit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: userName.value,
                        email: userEmail.value || '',
                        phone: userPhone.value || null,
                        position: selectedPosition.value.name,
                        choice_score: choiceScore.value,
                        total_choice: totalChoiceQuestions.value,
                        personality_analysis: personalityAnalysis,
                        avg_response_time: behaviorStats.value.avgResponseTime,
                        answer_change_count: behaviorData.value.answerChanges.reduce((sum, c) => sum + c, 0),
                        behavior_pattern: behaviorStats.value.pattern,
                        answers: answersData,
                        challenge_answers: challengeData
                    })
                });

                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    console.warn('提交警告:', err);
                    // 即使提交失敗也顯示結果（避免考生困惑）
                }

                currentStep.value = 'result';
            } catch (err) {
                console.error('Submit error:', err);
                // 即使出錯也顯示結果頁面
                currentStep.value = 'result';
            } finally {
                isSubmitting.value = false;
            }
        };

        // 挑戰題導航
        const nextChallenge = () => {
            if (currentChallengeIndex.value < challengeQuestions.value.length - 1) {
                currentChallengeIndex.value++;
                startTimer();
            }
        };

        const submitChallenge = async () => {
            stopTimer();
            await finalSubmit();
        };

        const currentChallenge = computed(() => {
            return challengeQuestions.value[currentChallengeIndex.value] || {};
        });

        const resetTest = () => {
            currentStep.value = 'welcome';
            userName.value = '';
            selectedPosition.value = null;
            currentQuestionIndex.value = 0;
            answers.value = {};
            shuffledQuestions.value = []; // 清空洗牌後的題目
        };

        const isCorrect = (idx) => {
            const q = currentQuestions.value[idx];
            return q.type === 'choice' && answers.value[idx] === q.answer;
        };

        const getTypeBadgeClass = (type, category) => {
            if (category === '人格特質') return 'badge-secondary';
            switch (type) {
                case 'choice': return 'badge-info';
                case 'implement': return 'badge-warning';
                case 'review': return 'badge-error';
                default: return 'badge-ghost';
            }
        };

        const getTypeLabel = (type) => {
            switch (type) {
                case 'choice': return '選擇題';
                case 'implement': return '實作題';
                case 'review': return 'Code Review';
                default: return type;
            }
        };

        const formatCode = (code) => {
            return code
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/(const|let|var|function|async|await|return|if|else|for|while|import|from|export|class|extends|new|this|try|catch|throw)/g, '<span class="keyword">$1</span>')
                .replace(/(".*?"|'.*?'|`.*?`)/g, '<span class="string">$1</span>')
                .replace(/(\/\/.*)/g, '<span class="comment">$1</span>');
        };

        const exportResult = () => {
            // 人格特質分析（僅供主考官參考）
            const personalityAnalysis = {};
            for (const [key, trait] of Object.entries(personalityScores.value)) {
                personalityAnalysis[key] = {
                    label: trait.label,
                    score: trait.score,
                    total: trait.total,
                    percentage: trait.total > 0 ? Math.round(trait.score / trait.total * 100) : 0
                };
            }

            const result = {
                name: userName.value,
                email: userEmail.value,
                phone: userPhone.value,
                position: selectedPosition.value?.name,
                timestamp: new Date().toISOString(),
                choiceScore: choiceScore.value,
                totalChoiceQuestions: totalChoiceQuestions.value,
                personalityAnalysis, // 人格特質分析
                answers: currentQuestions.value.map((q, idx) => ({
                    question: q.question,
                    type: q.type,
                    category: q.category,
                    answer: q.type === 'choice' ? q.options[answers.value[idx]] : answers.value[idx],
                    correct: q.type === 'choice' ? answers.value[idx] === q.answer : null,
                    trait: q.trait || null
                })),
                challengeAnswers: challengeQuestions.value.map((q, idx) => ({
                    question: q.question,
                    category: q.category,
                    answer: q.options ? q.options[challengeAnswers.value[idx]] : challengeAnswers.value[idx]
                }))
            };

            const blob = new Blob([JSON.stringify(result, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `smai-test-${userName.value}-${Date.now()}.json`;
            a.click();
        };

        return {
            // 主題
            themes,
            currentTheme,
            setTheme,
            toggleDarkMode,
            // 隨機名字
            randomStar,
            // AI 助理
            aiMessage: dynamicAiMessage,
            behaviorStats,
            trackAnswerChange,
            // 計時器
            timeRemaining,
            timerProgress,
            timerDanger,
            // 挑戰題
            challengeQuestions,
            challengeAnswers,
            currentChallengeIndex,
            currentChallenge,
            isGeneratingChallenge,
            nextChallenge,
            submitChallenge,
            // 原有
            currentStep,
            userName,
            userEmail,
            userPhone,
            selectedPosition,
            showJd,
            positions,
            currentQuestionIndex,
            currentQuestions,
            currentQuestion,
            answers,
            choiceScore,
            totalChoiceQuestions,
            personalityScores,
            resultEncouragement,
            isSubmitting,
            submitError,
            startTest,
            nextQuestion,
            prevQuestion,
            submitTest,
            resetTest,
            isCorrect,
            getTypeBadgeClass,
            getTypeLabel,
            formatCode,
        };
    }
}).mount('#app');

// Initialize Lucide icons
lucide.createIcons();
</script>
</body>
</html>
